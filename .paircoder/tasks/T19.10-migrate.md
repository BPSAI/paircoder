---
id: T19.10
title: Add `bpsai-pair migrate` command for legacy structure upgrades
plan: sprint-19
priority: 2
complexity: 45
status: done
depends_on: []
trello_card_id: null
---

# T19.10: Migration Command for Legacy Structures

## Goal

Add a `bpsai-pair migrate` command that detects legacy PairCoder structures and upgrades them to the current v2.4+ format, making it easy for users to upgrade existing projects.

## Background

Users upgrading from older versions face manual migration work:
- v1.x had `.paircoder.yml` + `context/` at root
- Early v2.x may be missing `.claude/`, skills, or config sections
- Config schema has evolved (trello, hooks, estimation sections added)

## Proposed CLI Interface

```bash
# Detect current version and show what would change
bpsai-pair migrate --dry-run

# Run migration with automatic backup
bpsai-pair migrate

# Run without backup (for CI or if already backed up)
bpsai-pair migrate --no-backup

# Specify preset for missing config sections
bpsai-pair migrate --preset bps
```

## Implementation

### File: `tools/cli/bpsai_pair/commands/migrate.py` (new)

```python
"""Migration command for upgrading legacy PairCoder structures."""
from pathlib import Path
from dataclasses import dataclass
from enum import Enum
import shutil
import click
import yaml
from datetime import datetime

class LegacyVersion(Enum):
    V1_LEGACY = "v1.x"           # .paircoder.yml + context/
    V2_EARLY = "v2.0-2.1"        # .paircoder/ but missing pieces
    V2_PARTIAL = "v2.2-2.3"      # Has structure, missing config sections
    V2_CURRENT = "v2.4+"         # Current format
    UNKNOWN = "unknown"

@dataclass
class MigrationPlan:
    """What needs to happen during migration."""
    source_version: LegacyVersion
    target_version: str = "2.4"
    
    # Files to move
    file_moves: list[tuple[Path, Path]] = None  # (src, dst)
    
    # Directories to create
    dirs_to_create: list[Path] = None
    
    # Config sections to add
    config_additions: dict = None
    
    # Files to delete after migration
    files_to_delete: list[Path] = None
    
    # Warnings/notes for user
    warnings: list[str] = None


def detect_version(project_root: Path) -> LegacyVersion:
    """Detect which version of PairCoder structure exists."""
    
    # v1.x indicators
    has_legacy_yml = (project_root / ".paircoder.yml").exists()
    has_root_context = (project_root / "context").is_dir()
    has_prompts = (project_root / "prompts").is_dir()
    
    # v2.x indicators
    has_paircoder_dir = (project_root / ".paircoder").is_dir()
    has_claude_dir = (project_root / ".claude").is_dir()
    has_config_yaml = (project_root / ".paircoder" / "config.yaml").exists()
    
    if has_legacy_yml or (has_root_context and not has_paircoder_dir):
        return LegacyVersion.V1_LEGACY
    
    if has_paircoder_dir and has_config_yaml:
        # Check config version
        config = yaml.safe_load((project_root / ".paircoder" / "config.yaml").read_text())
        version = config.get("version", "1.0")
        
        if version.startswith("2.4") or version.startswith("2.5") or version.startswith("2.6"):
            return LegacyVersion.V2_CURRENT
        elif version.startswith("2.2") or version.startswith("2.3"):
            return LegacyVersion.V2_PARTIAL
        else:
            return LegacyVersion.V2_EARLY
    
    if has_paircoder_dir and not has_config_yaml:
        return LegacyVersion.V2_EARLY
    
    return LegacyVersion.UNKNOWN


def plan_migration(project_root: Path, preset: str = None) -> MigrationPlan:
    """Create a migration plan based on detected version."""
    version = detect_version(project_root)
    plan = MigrationPlan(
        source_version=version,
        file_moves=[],
        dirs_to_create=[],
        config_additions={},
        files_to_delete=[],
        warnings=[],
    )
    
    paircoder_dir = project_root / ".paircoder"
    claude_dir = project_root / ".claude"
    
    if version == LegacyVersion.V1_LEGACY:
        # Full migration from v1.x
        plan.dirs_to_create = [
            paircoder_dir,
            paircoder_dir / "context",
            paircoder_dir / "flows",
            paircoder_dir / "plans",
            paircoder_dir / "tasks",
            paircoder_dir / "history",
            claude_dir,
            claude_dir / "skills",
            claude_dir / "agents",
        ]
        
        # Move context files
        if (project_root / "context" / "development.md").exists():
            plan.file_moves.append((
                project_root / "context" / "development.md",
                paircoder_dir / "context" / "state.md"
            ))
            plan.warnings.append(
                "state.md format has changed - manual review recommended"
            )
        
        if (project_root / "context" / "project.md").exists():
            plan.file_moves.append((
                project_root / "context" / "project.md",
                paircoder_dir / "context" / "project.md"
            ))
        
        # Mark for deletion after successful migration
        plan.files_to_delete = [
            project_root / ".paircoder.yml",
            project_root / "context",
            project_root / "prompts",
        ]
        
        plan.warnings.append(
            ".paircoder.yml config needs manual conversion to config.yaml"
        )
    
    elif version == LegacyVersion.V2_EARLY:
        # Add missing directories
        for subdir in ["flows", "plans", "tasks", "history"]:
            path = paircoder_dir / subdir
            if not path.exists():
                plan.dirs_to_create.append(path)
        
        if not claude_dir.exists():
            plan.dirs_to_create.extend([
                claude_dir,
                claude_dir / "skills",
                claude_dir / "agents",
            ])
    
    # For v2.2+ and partial v2.x, check config sections
    if version in [LegacyVersion.V2_EARLY, LegacyVersion.V2_PARTIAL]:
        if (paircoder_dir / "config.yaml").exists():
            config = yaml.safe_load((paircoder_dir / "config.yaml").read_text())
            
            # Check for missing sections
            if "trello" not in config:
                plan.config_additions["trello"] = {
                    "enabled": False,
                    "board_id": "",
                }
            
            if "hooks" not in config:
                plan.config_additions["hooks"] = {
                    "enabled": True,
                    "on_task_start": ["start_timer", "sync_trello", "update_state"],
                    "on_task_complete": ["stop_timer", "record_metrics", "sync_trello", "update_state", "check_unblocked"],
                }
            
            if "estimation" not in config:
                plan.config_additions["estimation"] = {
                    "complexity_to_hours": {
                        "xs": {"range": [0, 15], "hours": [0.5, 1.0, 2.0]},
                        "s": {"range": [16, 30], "hours": [1.0, 2.0, 4.0]},
                        "m": {"range": [31, 50], "hours": [2.0, 4.0, 8.0]},
                        "l": {"range": [51, 75], "hours": [4.0, 8.0, 16.0]},
                        "xl": {"range": [76, 100], "hours": [8.0, 16.0, 32.0]},
                    }
                }
            
            if "metrics" not in config:
                plan.config_additions["metrics"] = {
                    "enabled": True,
                    "store_path": ".paircoder/history/metrics.jsonl",
                }
    
    # Check for missing root files
    if not (project_root / "CLAUDE.md").exists():
        plan.warnings.append("CLAUDE.md missing - will be created from template")
    
    if not (project_root / "AGENTS.md").exists():
        plan.warnings.append("AGENTS.md missing - will be created from template")
    
    return plan


def create_backup(project_root: Path) -> Path:
    """Create timestamped backup of .paircoder/ and related files."""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_dir = project_root / f".paircoder_backup_{timestamp}"
    
    if (project_root / ".paircoder").exists():
        shutil.copytree(project_root / ".paircoder", backup_dir / ".paircoder")
    
    if (project_root / ".claude").exists():
        shutil.copytree(project_root / ".claude", backup_dir / ".claude")
    
    # v1.x files
    if (project_root / ".paircoder.yml").exists():
        shutil.copy2(project_root / ".paircoder.yml", backup_dir / ".paircoder.yml")
    
    if (project_root / "context").is_dir():
        shutil.copytree(project_root / "context", backup_dir / "context")
    
    return backup_dir


def execute_migration(project_root: Path, plan: MigrationPlan) -> None:
    """Execute the migration plan."""
    
    # Create directories
    for dir_path in plan.dirs_to_create or []:
        dir_path.mkdir(parents=True, exist_ok=True)
    
    # Move files
    for src, dst in plan.file_moves or []:
        if src.exists():
            dst.parent.mkdir(parents=True, exist_ok=True)
            shutil.move(str(src), str(dst))
    
    # Update config
    if plan.config_additions:
        config_path = project_root / ".paircoder" / "config.yaml"
        if config_path.exists():
            config = yaml.safe_load(config_path.read_text())
            config.update(plan.config_additions)
            config["version"] = plan.target_version
            
            with open(config_path, "w") as f:
                yaml.dump(config, f, default_flow_style=False, sort_keys=False)
    
    # Delete old files (only after everything else succeeds)
    for path in plan.files_to_delete or []:
        if path.is_dir():
            shutil.rmtree(path, ignore_errors=True)
        elif path.is_file():
            path.unlink(missing_ok=True)


@click.command("migrate")
@click.option("--dry-run", is_flag=True, help="Show what would change without making changes")
@click.option("--no-backup", is_flag=True, help="Skip backup creation")
@click.option("--preset", type=str, help="Preset to use for missing config sections")
@click.pass_context
def migrate_cmd(ctx, dry_run: bool, no_backup: bool, preset: str):
    """Migrate legacy PairCoder structure to current version."""
    project_root = Path.cwd()
    
    # Detect and plan
    version = detect_version(project_root)
    click.echo(f"Detected version: {version.value}")
    
    if version == LegacyVersion.V2_CURRENT:
        click.echo("‚úÖ Already at current version. No migration needed.")
        return
    
    if version == LegacyVersion.UNKNOWN:
        click.echo("‚ùå Could not detect PairCoder structure. Run 'bpsai-pair init' instead.")
        ctx.exit(1)
    
    plan = plan_migration(project_root, preset)
    
    # Show plan
    click.echo("\nüìã Migration Plan:")
    
    if plan.dirs_to_create:
        click.echo("\n  Directories to create:")
        for d in plan.dirs_to_create:
            click.echo(f"    üìÅ {d.relative_to(project_root)}")
    
    if plan.file_moves:
        click.echo("\n  Files to move:")
        for src, dst in plan.file_moves:
            click.echo(f"    üìÑ {src.relative_to(project_root)} ‚Üí {dst.relative_to(project_root)}")
    
    if plan.config_additions:
        click.echo("\n  Config sections to add:")
        for section in plan.config_additions:
            click.echo(f"    ‚öôÔ∏è  {section}")
    
    if plan.files_to_delete:
        click.echo("\n  Files to remove after migration:")
        for f in plan.files_to_delete:
            click.echo(f"    üóëÔ∏è  {f.relative_to(project_root)}")
    
    if plan.warnings:
        click.echo("\n  ‚ö†Ô∏è  Warnings:")
        for w in plan.warnings:
            click.echo(f"    ‚Ä¢ {w}")
    
    if dry_run:
        click.echo("\n--dry-run specified. No changes made.")
        return
    
    # Confirm
    if not click.confirm("\nProceed with migration?"):
        click.echo("Aborted.")
        return
    
    # Backup
    if not no_backup:
        click.echo("\nüì¶ Creating backup...")
        backup_path = create_backup(project_root)
        click.echo(f"   Backup saved to: {backup_path}")
    
    # Execute
    click.echo("\nüîÑ Migrating...")
    execute_migration(project_root, plan)
    
    click.echo("\n‚úÖ Migration complete!")
    click.echo("\nNext steps:")
    click.echo("  1. Review .paircoder/config.yaml")
    click.echo("  2. Run 'bpsai-pair validate' to check structure")
    click.echo("  3. Run 'bpsai-pair status' to verify")
```

### Register in CLI

Add to `cli.py`:
```python
from bpsai_pair.commands.migrate import migrate_cmd
app.add_command(migrate_cmd)
```

## Acceptance Criteria

- [ ] `bpsai-pair migrate --dry-run` detects version and shows plan
- [ ] `bpsai-pair migrate` creates backup by default
- [ ] `bpsai-pair migrate --no-backup` skips backup
- [ ] v1.x migration moves files correctly
- [ ] v2.x migration adds missing config sections
- [ ] Warnings shown for manual review items
- [ ] Config version updated to 2.4+
- [ ] Unit tests for `detect_version()`
- [ ] Unit tests for `plan_migration()`
- [ ] Integration test with tmp_path fixtures

## Test Cases

```python
def test_detect_v1_legacy(tmp_path):
    """Detect v1.x structure with .paircoder.yml."""
    (tmp_path / ".paircoder.yml").write_text("version: 1.0")
    (tmp_path / "context").mkdir()
    assert detect_version(tmp_path) == LegacyVersion.V1_LEGACY

def test_detect_v2_current(tmp_path):
    """Detect current v2.4+ structure."""
    (tmp_path / ".paircoder").mkdir()
    (tmp_path / ".paircoder" / "config.yaml").write_text("version: '2.4'")
    assert detect_version(tmp_path) == LegacyVersion.V2_CURRENT

def test_migration_creates_backup(tmp_path):
    """Ensure backup created before migration."""
    # Setup v2.2 structure
    (tmp_path / ".paircoder").mkdir()
    (tmp_path / ".paircoder" / "config.yaml").write_text("version: '2.2'")
    
    backup = create_backup(tmp_path)
    assert backup.exists()
    assert (backup / ".paircoder" / "config.yaml").exists()

def test_config_sections_added(tmp_path):
    """Missing config sections added during migration."""
    (tmp_path / ".paircoder").mkdir()
    (tmp_path / ".paircoder" / "config.yaml").write_text(
        "version: '2.2'\nproject:\n  name: test"
    )
    
    plan = plan_migration(tmp_path)
    assert "trello" in plan.config_additions
    assert "hooks" in plan.config_additions
```

## Effort Estimate

- Complexity: 45
- Effort: M (4-6 hours)
- Risk: Low (file operations well-tested with shutil)

## Notes

- Pure Python using pathlib and shutil
- No shell/bash dependencies
- Cross-platform compatible
- Follows existing CLI patterns (Click, YAML)
