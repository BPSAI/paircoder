---
id: T29.7
title: Test Containment Escape Attempts
status: done
priority: P0
complexity: 45
plan: plan-2026-01-sprint-29-contained-autonomy
depends_on:
- T29.4
---

# Objective

Create comprehensive tests that attempt to bypass containment restrictions. These tests ensure the containment is secure against common bypass techniques.

# ⚠️ CRITICAL DISCOVERY (from T29.6)

During T29.6 implementation, we discovered that **containment is currently advisory, not enforced**:

## The Gap

1. **Containment requires explicit activation**: The `ContainmentManager._active` flag defaults to `False`. Only the `contained-auto` command activates it.

2. **No tool-level integration**: Even when active, `ContainmentManager.check_write_allowed()` is never called by Claude Code's Write/Edit tools. The checks exist but nothing invokes them.

3. **Proof**: During T29.6, Claude successfully wrote to `bpsai_pair/security/` which should have been read-only per containment config, because:
   - Session was not started via `contained-auto`
   - Even if it were, Write tool doesn't call containment checks

## Current Architecture (Broken)

```
ContainmentManager.check_write_allowed()  →  Raises exception if blocked
                    ↑
                    │ (NOTHING CALLS THIS!)
                    │
Claude Code Write tool  →  Directly writes to filesystem
```

## Required for True Containment

This task must evaluate and document integration paths:

1. **State Machine Integration**: Track containment state, gate operations
2. **Docker Sandbox Integration**: Use existing `SandboxRunner` with read-only mounts
3. **Hook System**: Pre-operation hooks that check containment before execution
4. **Claude Code Integration**: Would require upstream changes to Claude Code tools

## Expanded Scope

This task should now also:
- Document the enforcement gap
- Evaluate integration options with existing systems (sandbox, state machine)
- Propose architecture for true containment enforcement
- Test that proposed enforcement actually blocks escapes

# Existing Systems Analysis

## 1. Docker Sandbox (`security/sandbox.py`)

**Capabilities:**
- `SandboxRunner`: Runs commands in isolated Docker containers
- `MountConfig(readonly=True)`: Support for read-only mounts
- Network isolation: `network: "none"` by default
- File change tracking via `container.diff()`
- Resource limits (memory, CPU)

**Key Insight:** This provides **TRUE filesystem isolation** via Docker. If we run
the Claude agent inside a Docker container with readonly mounts, the OS enforces
protection - no bypass possible.

```python
# Example: Read-only mount for .claude/skills/
MountConfig(
    source="/project/.claude/skills",
    target="/workspace/.claude/skills",
    readonly=True  # OS-enforced!
)
```

## 2. Hook System (`core/hooks.py`)

**Capabilities:**
- Event-based triggers: `on_task_start`, `on_task_complete`, `on_task_block`
- Extensible handler registry
- Can add new hooks like `on_containment_violation`

**Limitation:** Hooks can log and warn but can't prevent Claude Code's
direct file writes (unless integrated at tool level).

## 3. State Machine (`core/task_state.py`)

**Capabilities:**
- Task states: NOT_STARTED → BUDGET_CHECKED → IN_PROGRESS → AC_VERIFIED → COMPLETED
- Valid transition enforcement
- History tracking
- `is_state_machine_enabled()` config check

**Potential Extension:** Add CONTAINMENT_ACTIVE state:
```
NOT_STARTED → BUDGET_CHECKED → CONTAINMENT_ENTERED → IN_PROGRESS → ...
```

## 4. ContainmentManager (`security/containment.py`)

**Capabilities:**
- Three-tier access control (blocked/readonly/readwrite)
- Path checking with symlink resolution
- Glob pattern support
- `check_write_allowed()` / `check_read_allowed()` methods

**Gap:** Nothing calls these methods. They exist but are never invoked.

# Proposed Architecture for True Containment

## Option A: Docker-Based Enforcement (Recommended)

```
┌─────────────────────────────────────────────────────────────────┐
│                     Host System                                  │
├─────────────────────────────────────────────────────────────────┤
│  bpsai-pair contained-auto                                       │
│       │                                                          │
│       ▼                                                          │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │  Docker Container (SandboxRunner)                           ││
│  │  ┌─────────────────────────────────────────────────────────┐││
│  │  │  Claude Code Process                                    │││
│  │  │       │                                                 │││
│  │  │       ▼                                                 │││
│  │  │  ContainmentManager (advisory logging)                  │││
│  │  └─────────────────────────────────────────────────────────┘││
│  │                                                             ││
│  │  Mounts:                                                    ││
│  │  - /workspace        (rw) - working area                   ││
│  │  - /workspace/.claude/skills  (ro) - OS ENFORCED           ││
│  │  - /workspace/CLAUDE.md       (ro) - OS ENFORCED           ││
│  │  - /workspace/.env            (blocked - not mounted)       ││
│  │                                                             ││
│  │  Network: none (or allowlist via iptables)                  ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

**Pros:**
- TRUE enforcement via OS-level read-only mounts
- No bypass possible (short of container escape)
- Already have SandboxRunner infrastructure

**Cons:**
- Requires Docker to be installed and running
- Performance overhead
- More complex setup

## Option B: Advisory + Audit Trail

```
┌─────────────────────────────────────────────────────────────────┐
│  Claude Code Process (native)                                    │
│       │                                                          │
│       ▼                                                          │
│  Pre-operation Hook (if Claude Code supports it)                 │
│       │                                                          │
│       ▼                                                          │
│  ContainmentManager.check_write_allowed()                        │
│       │                                                          │
│       ├── Pass → Allow operation                                 │
│       └── Fail → Log to bypass_log.jsonl + WARN                  │
│                  (but operation still completes)                 │
└─────────────────────────────────────────────────────────────────┘
```

**Pros:**
- No Docker required
- Lightweight
- Good for development/trust scenarios

**Cons:**
- NOT TRUE ENFORCEMENT - just logging
- Relies on Claude's "good behavior"
- Can be bypassed by any subprocess

## Option C: Hybrid (Best of Both)

1. **Development/Trust Mode**: Use Option B (advisory + audit)
2. **Production/Strict Mode**: Use Option A (Docker enforcement)

Config switch:
```yaml
containment:
  enabled: true
  mode: strict  # 'strict' = Docker, 'advisory' = log-only
```

# Network Containment Integration

The `NetworkGuard` (T29.6) can be integrated:

1. **Docker mode**: Use `network: none` + iptables rules for allowlist
2. **Advisory mode**: Hook into requests library, log blocked attempts

# Files to Update

| File | Change |
|------|--------|
| `tests/security/test_containment_escapes.py` | Create comprehensive escape test suite |

# Implementation Plan

1. Create test fixtures for containment environment

2. Implement symlink escape tests:
   - `test_symlink_to_locked_dir`
   - `test_symlink_chain_to_locked_file`
   - `test_relative_symlink_escape`

3. Implement path traversal escape tests:
   - `test_dotdot_traversal`
   - `test_double_slash_traversal`
   - `test_encoded_path_traversal`
   - `test_null_byte_injection`

4. Implement filesystem escape tests:
   - `test_hardlink_to_locked_file`
   - `test_rename_locked_directory`
   - `test_move_file_to_locked_dir`

5. Implement process escape tests:
   - `test_subprocess_with_modified_path`
   - `test_shell_command_injection`
   - `test_env_var_override`

6. Implement network escape tests:
   - `test_ip_instead_of_domain`
   - `test_redirect_to_blocked_domain`

7. Verify all escape attempts are logged to audit

# Acceptance Criteria

- [ ] 20+ escape attempt test cases
- [ ] Symlink bypass attempts blocked
- [ ] Relative path traversal blocked (../)
- [ ] Hardlink bypass attempts blocked
- [ ] Subprocess spawn with modified PATH blocked
- [ ] Environment variable injection blocked
- [ ] All escape attempts logged to audit

# Verification

```bash
# Run all escape tests
pytest tests/security/test_containment_escapes.py -v

# Verify count
pytest tests/security/test_containment_escapes.py --collect-only | grep "test_" | wc -l
# Should be >= 20
```

# Implementation Notes

```python
# tests/security/test_containment_escapes.py

import pytest
from pathlib import Path
from bpsai_pair.security.containment import ContainmentManager, ContainmentViolationError
from bpsai_pair.core.config import ContainmentConfig

@pytest.fixture
def containment_manager(tmp_path):
    """Create a sandbox manager with locked paths."""
    locked_dir = tmp_path / ".claude" / "agents"
    locked_dir.mkdir(parents=True)
    locked_file = tmp_path / "CLAUDE.md"
    locked_file.touch()

    config = ContainmentConfig(
        enabled=True,
        locked_directories=[".claude/agents/"],
        locked_files=["CLAUDE.md"]
    )
    manager = ContainmentManager(config, tmp_path)
    manager.activate()
    return manager, tmp_path


class TestSymlinkEscapes:
    """Attempts to bypass via symlinks."""

    def test_symlink_to_locked_dir(self, containment_manager):
        manager, root = containment_manager
        # Create symlink pointing to locked dir
        symlink = root / "sneaky_link"
        symlink.symlink_to(root / ".claude" / "agents")

        with pytest.raises(ContainmentViolationError):
            manager.check_write_allowed(symlink / "planner.md")

    def test_symlink_chain_to_locked_file(self, containment_manager):
        manager, root = containment_manager
        # Create chain: link1 -> link2 -> locked file
        link2 = root / "link2"
        link2.symlink_to(root / "CLAUDE.md")
        link1 = root / "link1"
        link1.symlink_to(link2)

        with pytest.raises(ContainmentViolationError):
            manager.check_write_allowed(link1)


class TestPathTraversalEscapes:
    """Attempts to bypass via path manipulation."""

    def test_dotdot_traversal(self, containment_manager):
        manager, root = containment_manager
        # Try .claude/../.claude/agents
        sneaky_path = Path(".claude/../.claude/agents/planner.md")

        with pytest.raises(ContainmentViolationError):
            manager.check_write_allowed(sneaky_path)


class TestFilesystemEscapes:
    """Attempts to bypass via filesystem tricks."""

    def test_rename_locked_directory(self, containment_manager):
        manager, root = containment_manager
        # Try to rename .claude/agents to something else
        with pytest.raises(ContainmentViolationError):
            manager.check_write_allowed(root / ".claude" / "agents")


class TestNetworkEscapes:
    """Attempts to bypass network restrictions."""
    pass  # Implemented with NetworkGuard tests
```

# Test Categories Summary

| Category | Tests |
|----------|-------|
| Symlink Escapes | 3-4 tests |
| Path Traversal | 4-5 tests |
| Filesystem Tricks | 3-4 tests |
| Process Manipulation | 3-4 tests |
| Network Escapes | 3-4 tests |
| Environment Injection | 2-3 tests |
| **Total** | **20+ tests** |

# Deliverables

- Test file with 20+ test cases
- All tests passing (escapes blocked)
- Audit log contains all attempts