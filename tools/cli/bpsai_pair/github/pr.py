"""
Pull Request management for PairCoder.

Provides task-linked PR creation, status tracking, and automation.
"""
from __future__ import annotations

import logging
import re
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict, Any, Callable

from .client import GitHubClient, GitHubService

logger = logging.getLogger(__name__)


@dataclass
class PRInfo:
    """Pull request information."""

    number: int
    title: str
    url: str
    state: str  # open, closed, merged
    task_id: Optional[str] = None
    branch: Optional[str] = None
    base_branch: str = "main"
    draft: bool = False
    mergeable: Optional[bool] = None
    review_decision: Optional[str] = None  # APPROVED, CHANGES_REQUESTED, etc.
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    @classmethod
    def from_gh_json(cls, data: Dict[str, Any]) -> "PRInfo":
        """Create PRInfo from gh CLI JSON output.

        Args:
            data: JSON data from gh pr view/list

        Returns:
            PRInfo instance
        """
        # Extract task ID from title if present
        task_id = None
        title = data.get("title", "")
        task_match = re.search(r"\[?(TASK-\d+)\]?", title)
        if task_match:
            task_id = task_match.group(1)

        return cls(
            number=data.get("number", 0),
            title=title,
            url=data.get("url", data.get("html_url", "")),
            state=data.get("state", "open").lower(),
            task_id=task_id,
            branch=data.get("headRefName"),
            base_branch=data.get("baseRefName", "main"),
            draft=data.get("isDraft", False),
            mergeable=data.get("mergeable") == "MERGEABLE",
            review_decision=data.get("reviewDecision"),
        )

    def is_approved(self) -> bool:
        """Check if PR is approved."""
        return self.review_decision == "APPROVED"

    def is_ready_to_merge(self) -> bool:
        """Check if PR is ready to merge."""
        return (
            self.state == "open"
            and not self.draft
            and self.mergeable is True
            and self.is_approved()
        )


class PRManager:
    """Manager for task-linked pull requests."""

    # Template for PR body
    PR_BODY_TEMPLATE = """## Summary
{summary}

## Task
- **ID**: {task_id}
- **Title**: {task_title}
- **Plan**: {plan_id}

## Changes
{changes}

## Test Plan
{test_plan}

---
Generated by [PairCoder](https://github.com/bps-ai/paircoder)
"""

    def __init__(
        self,
        service: Optional[GitHubService] = None,
        project_root: Optional[Path] = None,
        paircoder_dir: Optional[Path] = None,
    ):
        """Initialize PR manager.

        Args:
            service: GitHub service (creates default if not provided)
            project_root: Project root directory
            paircoder_dir: Path to .paircoder directory
        """
        self.project_root = project_root or Path.cwd()
        self.service = service or GitHubService(project_root=self.project_root)
        self.paircoder_dir = paircoder_dir or (self.project_root / ".paircoder")

    def create_pr_for_task(
        self,
        task_id: str,
        summary: str,
        changes: Optional[str] = None,
        test_plan: Optional[str] = None,
        draft: bool = False,
        base: Optional[str] = None,
    ) -> Optional[PRInfo]:
        """Create a PR for a task.

        Args:
            task_id: Task ID (e.g., TASK-001)
            summary: Brief summary of changes
            changes: Detailed list of changes
            test_plan: Testing instructions
            draft: Create as draft PR
            base: Base branch (uses default if not provided)

        Returns:
            PRInfo if created successfully
        """
        # Try to get task info
        task_title = task_id
        plan_id = "unknown"

        try:
            from ..planning.parser import TaskParser
            parser = TaskParser(self.paircoder_dir / "tasks")
            task = parser.get(task_id)
            if task:
                task_title = task.title
                plan_id = task.plan_id or "unknown"
        except Exception as e:
            logger.warning(f"Could not load task info: {e}")

        # Build PR title and body
        title = f"[{task_id}] {task_title}"
        body = self.PR_BODY_TEMPLATE.format(
            summary=summary,
            task_id=task_id,
            task_title=task_title,
            plan_id=plan_id,
            changes=changes or "- See commits for detailed changes",
            test_plan=test_plan or "- [ ] Manual testing\n- [ ] Automated tests pass",
        )

        # Create PR
        result = self.service.client.create_pr(
            title=title,
            body=body,
            base=base,
            draft=draft,
            cwd=self.project_root,
        )

        if result:
            return PRInfo(
                number=result["number"],
                title=title,
                url=result["url"],
                state="open",
                task_id=task_id,
                draft=draft,
            )

        return None

    def get_pr_for_task(self, task_id: str) -> Optional[PRInfo]:
        """Get the PR associated with a task.

        Args:
            task_id: Task ID to search for

        Returns:
            PRInfo if found
        """
        # Search open PRs for task ID in title
        prs = self.service.client.list_prs(
            state="all",
            limit=100,
            cwd=self.project_root,
        )

        for pr_data in prs:
            title = pr_data.get("title", "")
            if task_id in title:
                # Get full PR info
                full_data = self.service.client.get_pr_status(
                    pr_number=pr_data["number"],
                    cwd=self.project_root,
                )
                if full_data:
                    pr_info = PRInfo.from_gh_json(full_data)
                    pr_info.task_id = task_id
                    return pr_info

        return None

    def get_pr_for_branch(self, branch: Optional[str] = None) -> Optional[PRInfo]:
        """Get PR for current or specified branch.

        Args:
            branch: Branch name (uses current if not provided)

        Returns:
            PRInfo if found
        """
        if branch is None:
            branch = self.service.get_current_branch()

        if not branch:
            return None

        # Get PR status for current branch
        status = self.service.client.get_pr_status(cwd=self.project_root)
        if status:
            return PRInfo.from_gh_json(status)

        return None

    def list_task_prs(
        self,
        plan_id: Optional[str] = None,
        state: str = "open",
    ) -> List[PRInfo]:
        """List PRs that are linked to tasks.

        Args:
            plan_id: Filter by plan ID
            state: PR state filter

        Returns:
            List of task-linked PRInfo objects
        """
        prs = self.service.client.list_prs(
            state=state,
            limit=100,
            cwd=self.project_root,
        )

        task_prs = []
        for pr_data in prs:
            pr_info = PRInfo.from_gh_json(pr_data)
            if pr_info.task_id:
                task_prs.append(pr_info)

        return task_prs

    def update_task_on_merge(
        self,
        pr_number: int,
        on_merge: Optional[Callable[[str], None]] = None,
    ) -> bool:
        """Update task status when PR is merged.

        Args:
            pr_number: PR number to check
            on_merge: Callback with task_id when merged

        Returns:
            True if task was updated
        """
        status = self.service.client.get_pr_status(
            pr_number=pr_number,
            cwd=self.project_root,
        )

        if not status:
            return False

        pr_info = PRInfo.from_gh_json(status)

        if pr_info.state == "merged" and pr_info.task_id:
            # Update task status to done
            try:
                from ..planning.parser import TaskParser
                from ..planning.models import TaskStatus

                parser = TaskParser(self.paircoder_dir / "tasks")
                task = parser.get(pr_info.task_id)
                if task:
                    task.status = TaskStatus.DONE
                    parser.save(task)
                    logger.info(f"Marked {pr_info.task_id} as done (PR #{pr_number} merged)")

                    if on_merge:
                        on_merge(pr_info.task_id)

                    return True
            except Exception as e:
                logger.error(f"Failed to update task: {e}")

        return False


class PRWorkflow:
    """Workflow automation for PRs."""

    def __init__(
        self,
        pr_manager: PRManager,
        auto_assign_next: bool = True,
    ):
        """Initialize PR workflow.

        Args:
            pr_manager: PR manager instance
            auto_assign_next: Auto-assign next task on merge
        """
        self.pr_manager = pr_manager
        self.auto_assign_next = auto_assign_next

    def on_task_complete(self, task_id: str) -> Optional[PRInfo]:
        """Handle task completion - create PR if on feature branch.

        Args:
            task_id: Completed task ID

        Returns:
            PRInfo if PR was created
        """
        branch = self.pr_manager.service.get_current_branch()
        if not branch:
            return None

        # Check if already on main
        default = self.pr_manager.service.client.get_default_branch(
            self.pr_manager.project_root
        )
        if branch == default:
            logger.info("On default branch, skipping PR creation")
            return None

        # Check if PR already exists
        existing = self.pr_manager.get_pr_for_branch(branch)
        if existing:
            logger.info(f"PR already exists: #{existing.number}")
            return existing

        # Create PR
        return self.pr_manager.create_pr_for_task(
            task_id=task_id,
            summary=f"Implementation of {task_id}",
        )

    def on_pr_merge(self, pr_number: int) -> Optional[str]:
        """Handle PR merge - update task and optionally assign next.

        Args:
            pr_number: Merged PR number

        Returns:
            Next task ID if assigned
        """
        next_task_id = None

        def on_merge(task_id: str):
            nonlocal next_task_id
            if self.auto_assign_next:
                try:
                    from ..planning.auto_assign import auto_assign_next
                    next_task = auto_assign_next(self.pr_manager.paircoder_dir)
                    if next_task:
                        next_task_id = next_task.id
                        logger.info(f"Auto-assigned next task: {next_task_id}")
                except Exception as e:
                    logger.error(f"Failed to auto-assign next task: {e}")

        self.pr_manager.update_task_on_merge(pr_number, on_merge)
        return next_task_id
